# Upcoming Departures from Predictions, Schedules, etc

```elixir
defmodule Departure do
  alias Predictions.Prediction
  alias Routes.Route

  @date_time_module Application.compile_env!(:dotcom, :date_time_module)

  def display(%Prediction{} = prediction) do
    bs = boarding_status(prediction)
    if bs do
      bs
    else
      countdown(prediction)
    end
  end

  def boarding_status(prediction) do
    rail_status = rail_status(prediction)
    boarding_time = boarding_time(prediction)
    if rail_status && boarding_time do
      boarding_time <> " " <> rail_status
    else
      if boarding_time, do: boarding_time
    end
  end
  
  def rail_status(%Prediction{route: %Route{type: type}}) when type != 2, do: nil
  def rail_status(%Prediction{status: nil, track: nil}), do: nil
  def rail_status(%Prediction{status: status, track: track}) do
    case {status, track} do
      {status, nil} -> status(status)
      {nil, track} -> track(track)
      _ ->
        status(status) <> " " <> track(track)
    end
  end

  defp status("All aboard"), do: "Last call"
  defp status(status), do: status
  defp track(track), do: "Track #{track}"

  def boarding_time(%Prediction{route: %Route{type: type}, time: time}) when type in [0, 1, 3] do
    if DateTime.diff(time, @date_time_module.now(), :second) <= 30 do
      if(type == 3, do: "Now", else: "Arriving")
    end
  end

  def boarding_time(_), do: nil

  def countdown(%Prediction{schedule_relationship: sr}) when sr in [:skipped, :cancelled] do
    sr
  end
  
  def countdown(%Prediction{time: time}) do
    diff = DateTime.diff(time, @date_time_module.now(), :second)
    if diff <= 0 do
      "Departed"
    else
      DotcomWeb.Components.TripPlanner.Helpers.seconds_to_localized_minutes(diff)
    end
  end
end
```

## Section

```elixir
Predictions.Repo.all(route: "CR-Fitchburg", "page[limit]": 20)
|> Enum.map(&Departure.display/1)
|> Enum.each(&IO.inspect/1)
```
