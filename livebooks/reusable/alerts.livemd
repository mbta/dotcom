# Mock Alerts

## Section

```elixir
import Dotcom.Utils.DateTime, only: [now: 0]

alias Test.Support.Factories.Alerts.{Alert, InformedEntity}

foxboro = InformedEntity.build(:informed_entity,
  route: "CR-Franklin",
  stop: "place-FS-0049"
)
informed_entity_set = Alerts.InformedEntitySet.new([foxboro])
alert = Alert.build(:alert,
  active_period: [{now() |> Timex.shift(hours: -2), now() |> Timex.shift(hours: 2)}],
  informed_entity: informed_entity_set,
  effect: :station_closure
)

alerts = [alert]

# Stop the fetcher so it doesn't update alerts
Supervisor.which_children(Dotcom.Supervisor)
|> Enum.find(fn {_, _, _, list} -> list == [Alerts.CacheSupervisor] end)
|> elem(1)
|> Supervisor.terminate_child(Alerts.Cache.Fetcher)

# Remove all other alerts and only use the one's you created
Alerts.Cache.Store.update(alerts, nil)

now() |> Alerts.Repo.all()
```

```elixir
IEx.Helpers.r(Dotcom.SystemStatus.CommuterRail)

Dotcom.SystemStatus.CommuterRail.commuter_rail_status()
```
