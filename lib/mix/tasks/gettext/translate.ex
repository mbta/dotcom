defmodule Mix.Tasks.Gettext.Translate do
  @moduledoc """
  This mix task translates all lines in every domain `.pot` file for every locale.

  Run Libretranslate locally loading only the locales we support.

  docker run -ti --rm -p 9999:5000 libretranslate/libretranslate --load-only en,es
  """

  @shortdoc "Translate all of the `.po` files using the `.pot` file(s)"

  use Mix.Task

  import Dotcom.Locales, only: [default_locale_code: 0, locale_codes: 0]

  @directory "priv/gettext"
  @url "http://localhost:9999/translate"

  @impl Mix.Task
  # Translate the `.pot` file(s) into the given locales.
  # E.g., `mix gettext.translate --locales es,fr`
  def run(["--locales", locales]) do
    _ = Finch.start_link(name: TranslateFinch)

    locales
    |> String.split(",")
    |> Enum.reject(fn locale ->
      locale === default_locale_code() || not Enum.member?(locale_codes(), locale)
    end)
    |> translate()
  end

  # Translate all non-default locales.
  def run([]) do
    _ = Finch.start_link(name: TranslateFinch)

    (locale_codes() -- [default_locale_code()]) |> translate()
  end

  # Translate the given locales.
  defp translate(locales) when is_list(locales) do
    Enum.each(locales, &translate/1)
  end

  # Translate a single locale.
  defp translate(locale) when is_binary(locale) do
    Enum.each(domains(), fn domain ->
      write_domain_translations(domain, locale)
    end)
  end

  # Build a request to be sent to Libretranslate.
  defp build_request(text, locale) do
    %{
      q: text,
      source: default_locale_code(),
      target: locale,
      alternatives: 3
    }
  end

  # Gets the content of msgid of a `.pot` file.
  defp domain_line(line) do
    Regex.scan(~r/(?<=\")(.*?)(?=\")/, line)
    |> List.flatten()
    |> List.first()
  end

  # Gets all of the msgids of a `.pot` file.
  defp domain_lines(domain) do
    "#{@directory}/#{domain}.pot"
    |> File.read!()
    |> String.split("\n", trim: true)
    |> Enum.filter(fn line -> String.match?(line, ~r/^msgid \"(.)+\"/) end)
    |> Enum.map(&domain_line/1)
  end

  # Looks for all `.pot` files to get a list of domains.
  defp domains() do
    @directory
    |> File.ls!()
    |> Enum.filter(fn ref -> String.match?(ref, ~r/.pot$/) end)
    |> Enum.map(fn ref -> String.split(ref, ".") |> List.first() end)
  end

  # Gets all of the domain lines in a domain and then translates them into the locale.
  defp translate_domain(domain, locale) do
    domain_lines(domain)
    |> Enum.map(fn text -> {text, translate_text(text, locale)} end)
    |> Map.new()
  end

  # Translates a piece of text to a specific locale via Libretranslate.
  defp translate_text(text, locale) do
    @url
    |> Req.post!(finch: TranslateFinch, json: build_request(text, locale))
    |> Map.get(:body)
    |> Map.new(fn {k, v} -> {Recase.to_snake(k), v} end)
  end

  # Writes a translated `.po` file for the domain and locale.
  defp write_domain_translations(domain, locale) do
    file = File.open!("#{@directory}/#{locale}/LC_MESSAGES/#{domain}.po", [:write, :utf8])

    IO.puts(file, "# THIS FILE WAS GENERATED BY RUNNING `mix gettext.translate`")
    IO.puts(file, "")

    translate_domain(domain, locale)
    |> Enum.each(fn {k, v} -> write_translation(file, k, v) end)
  end

  # Writes a single translation into a single file.
  defp write_translation(file, text, translation) do
    IO.puts(file, "msgid \"#{text}\"")
    IO.puts(file, "msgstr \"#{Map.get(translation, "translated_text")}\"")

    Map.get(translation, "alternatives")
    |> Enum.each(fn alternative ->
      IO.puts(file, "# Alternative: #{alternative}")
    end)

    IO.puts(file, "")
  end
end
